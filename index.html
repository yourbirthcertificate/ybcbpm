<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YBCBPM - dev mode</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-pulse { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .7; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script type="importmap">
{
  "imports": {
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.28.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "path": "https://aistudiocdn.com/path@^0.12.7",
    "vite": "https://aistudiocdn.com/vite@^7.2.0",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.0"
  }
}
</script>
    <link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script>
    (function(global) {
        "use strict";

        const workerCode = `
            const TARGET_SAMPLE_RATE = 11025;
            const MIN_BPM = 60;
            const MAX_BPM = 200;
            const VISUAL_WEIGHT = 0.35;
            const AUDIAL_WEIGHT = 0.65;
            const MAX_VISUAL_PEAKS = 600;
            const MAX_ALIGNMENT_PEAKS = 900;
            const VISUAL_LOOKAHEAD_PEAKS = 8;
            const PEAK_THRESHOLD_MULTIPLIER = 1.5;
            const ONSET_SMOOTHING_WINDOW_SECONDS = 0.04;

            // --- START: Key Detection Constants & Helpers ---
            const PITCH_CLASS_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const MAJOR_PROFILE = [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88];
            const MINOR_PROFILE = [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17];

            function fft(real, imag) {
                const n = real.length;
                if (n === 0) return;
                if ((n & (n - 1)) !== 0) {
                    console.warn('FFT input length is not a power of 2. Results may be incorrect.');
                }
                let j = 0;
                for (let i = 0; i < n; i++) {
                    if (i < j) {
                        [real[i], real[j]] = [real[j], real[i]];
                        [imag[i], imag[j]] = [imag[j], imag[i]];
                    }
                    let m = n >> 1;
                    while (j >= m && m > 0) {
                        j -= m;
                        m >>= 1;
                    }
                    j += m;
                }
                for (let size = 2; size <= n; size <<= 1) {
                    const halfSize = size >> 1;
                    const angleStep = -2 * Math.PI / size;
                    for (let i = 0; i < n; i += size) {
                        let cos = 1;
                        let sin = 0;
                        for (let j = i; j < i + halfSize; j++) {
                            const k = j + halfSize;
                            const tReal = real[k] * cos - imag[k] * sin;
                            const tImag = real[k] * sin + imag[k] * cos;
                            real[k] = real[j] - tReal;
                            imag[k] = imag[j] - tImag;
                            real[j] += tReal;
                            imag[j] += tImag;
                            const nextCos = cos * Math.cos(angleStep) - sin * Math.sin(angleStep);
                            sin = cos * Math.sin(angleStep) + sin * Math.cos(angleStep);
                            cos = nextCos;
                        }
                    }
                }
            }

            function fftMag(window) {
                const n = window.length;
                let N = 1;
                while (N < n) N <<= 1;
                const real = new Float32Array(N);
                real.set(window);
                const imag = new Float32Array(N);
                fft(real, imag);
                const mag = new Float32Array(N / 2);
                for (let i = 0; i < N / 2; i++) {
                    mag[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
                }
                return mag;
            }
            
            function applyHannWindow(buffer) {
                const N = buffer.length;
                for (let n = 0; n < N; n++) {
                    buffer[n] *= 0.5 * (1 - Math.cos((2 * Math.PI * n) / (N - 1)));
                }
            }

            function freqToPitchClass(freq) {
                const A4 = 440;
                const semitone = 12 * Math.log2(freq / A4);
                const midi = Math.round(semitone) + 69;
                return ((midi % 12) + 12) % 12;
            }

            function accumulateChromaFromSpectrum(spectrum, sampleRate, chroma) {
                const binCount = spectrum.length;
                const nyquist = sampleRate / 2;
                for (let bin = 1; bin < binCount; bin++) {
                    const freq = (bin / binCount) * nyquist;
                    if (freq < 50 || freq > 5000) continue;
                    const magnitude = spectrum[bin];
                    if (magnitude <= 0) continue;
                    const pitchClass = freqToPitchClass(freq);
                    chroma[pitchClass] += magnitude;
                }
            }

            function normalizeVector(v) {
                let sum = 0;
                for (let i = 0; i < v.length; i++) sum += v[i];
                if (sum <= 0) return;
                for (let i = 0; i < v.length; i++) v[i] /= sum;
            }
            
            function rotate(arr, shift) {
                const out = new Float32Array(12);
                for (let i = 0; i < 12; i++) {
                    out[i] = arr[(i - shift + 12) % 12];
                }
                return out;
            }

            function correlation(a, b) {
                let sum = 0, sumA2 = 0, sumB2 = 0;
                for (let i = 0; i < a.length; i++) {
                    sum += a[i] * b[i];
                    sumA2 += a[i] * a[i];
                    sumB2 += b[i] * b[i];
                }
                const denom = Math.sqrt(sumA2 * sumB2) || 1;
                return sum / denom;
            }
            
            function estimateKeyFromChroma(chroma) {
                let bestScore = -Infinity;
                let bestKey = null;

                for (let root = 0; root < 12; root++) {
                    const majorScore = correlation(chroma, rotate(MAJOR_PROFILE, root));
                    if (majorScore > bestScore) {
                        bestScore = majorScore;
                        bestKey = \`\${PITCH_CLASS_NAMES[root]} major\`;
                    }
                    const minorScore = correlation(chroma, rotate(MINOR_PROFILE, root));
                    if (minorScore > bestScore) {
                        bestScore = minorScore;
                        bestKey = \`\${PITCH_CLASS_NAMES[root]} minor\`;
                    }
                }
                const confidence = Math.max(0, Math.min(1, bestScore));
                return { key: bestKey, confidence };
            }

            function detectKey(pcm, sampleRate) {
                const maxSeconds = 45;
                const maxSamples = Math.min(pcm.length, maxSeconds * sampleRate);
                const segment = pcm.subarray(0, maxSamples);
                const windowSize = 4096;
                const hopSize = 2048;
                const chroma = new Float32Array(12);
                const window = new Float32Array(windowSize);
                let frames = 0;

                for (let start = 0; start + windowSize < segment.length; start += hopSize) {
                    window.set(segment.subarray(start, start + windowSize));
                    applyHannWindow(window);
                    const spectrum = fftMag(window);
                    accumulateChromaFromSpectrum(spectrum, sampleRate, chroma);
                    frames++;
                }

                if (frames === 0) return { key: null, confidence: 0 };

                normalizeVector(chroma);
                return estimateKeyFromChroma(chroma);
            }
            // --- END: Key Detection ---


            function mixDownToMono(buffer) {
                if (buffer.numberOfChannels === 1) {
                    return buffer.getChannelData(0).slice();
                }
                const length = buffer.length;
                const tmp = new Float32Array(length);
                for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        tmp[i] += channelData[i];
                    }
                }
                for (let i = 0; i < length; i++) {
                    tmp[i] /= buffer.numberOfChannels;
                }
                return tmp;
            }

            function downsampleBuffer(data, sampleRate, targetRate) {
                if (sampleRate <= targetRate) {
                    return data.slice();
                }
                const ratio = sampleRate / targetRate;
                const newLength = Math.floor(data.length / ratio);
                const downsampled = new Float32Array(newLength);
                for (let i = 0; i < newLength; i++) {
                    const start = Math.floor(i * ratio);
                    const end = Math.min(data.length, Math.floor((i + 1) * ratio));
                    let sum = 0;
                    let count = 0;
                    for (let j = start; j < end; j++) {
                        sum += data[j];
                        count++;
                    }
                    downsampled[i] = count > 0 ? sum / count : 0;
                }
                return downsampled;
            }

            function normalize(data) {
                let max = 0;
                for (let i = 0; i < data.length; i++) {
                    const value = Math.abs(data[i]);
                    if (value > max) {
                        max = value;
                    }
                }
                if (!max) return data;
                const normalized = new Float32Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    normalized[i] = data[i] / max;
                }
                return normalized;
            }

            function accumulateTempoEvidence(histogram, tempo, weight = 1) {
                if (!isFinite(tempo) || tempo <= 0 || !weight) return;
                let normalized = tempo;
                let attenuation = 1;
                while (normalized < MIN_BPM) {
                    normalized *= 2;
                    attenuation *= 0.5;
                }
                while (normalized > MAX_BPM) {
                    normalized /= 2;
                    attenuation *= 0.5;
                }
                if (normalized < MIN_BPM || normalized > MAX_BPM) return;
                const key = Math.round(normalized * 4) / 4;
                histogram.set(key, (histogram.get(key) || 0) + weight * attenuation);
            }

            function smoothAbsolute(signal, windowSize) {
                const smoothed = new Float32Array(signal.length);
                let accumulator = 0;
                for (let i = 0; i < signal.length; i++) {
                    const absValue = Math.abs(signal[i]);
                    accumulator += absValue;
                    if (i >= windowSize) {
                        accumulator -= Math.abs(signal[i - windowSize]);
                    }
                    const divisor = Math.min(windowSize, i + 1);
                    smoothed[i] = accumulator / divisor;
                }
                return smoothed;
            }

            function movingAverage(signal, windowSize) {
                if (windowSize <= 1) return signal.slice();
                const result = new Float32Array(signal.length);
                let sum = 0;
                for (let i = 0; i < signal.length; i++) {
                    sum += signal[i];
                    if (i >= windowSize) {
                        sum -= signal[i - windowSize];
                    }
                    const divisor = Math.min(windowSize, i + 1);
                    result[i] = sum / divisor;
                }
                return result;
            }

            function detectPeaks(data, sampleRate, thresholdMultiplier, minDistanceSeconds) {
                const peaks = [];
                let sum = 0;
                let sumSquares = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i];
                    sumSquares += data[i] * data[i];
                }
                const mean = sum / data.length;
                const variance = Math.max(sumSquares / data.length - mean * mean, 0);
                const stdDev = Math.sqrt(variance);
                const threshold = mean + stdDev * thresholdMultiplier;
                const minDistance = Math.max(1, Math.floor(minDistanceSeconds * sampleRate));
                let lastPeakIndex = -Infinity;

                for (let i = 1; i < data.length - 1; i++) {
                    const current = data[i];
                    if (current < threshold) continue;
                    if (current > data[i - 1] && current >= data[i + 1]) {
                        if (i - lastPeakIndex >= minDistance) {
                            peaks.push(i);
                            lastPeakIndex = i;
                        }
                    }
                }
                return peaks;
            }

            function visualTempoEstimation(envelopePeaks, sampleRate) {
                if (envelopePeaks.length < 2) return [];
                const histogram = new Map();
                const lookahead = VISUAL_LOOKAHEAD_PEAKS;
                for (let i = 0; i < envelopePeaks.length - 1; i++) {
                    const base = envelopePeaks[i];
                    const limit = Math.min(envelopePeaks.length, i + 1 + lookahead);
                    for (let j = i + 1; j < limit; j++) {
                        const interval = envelopePeaks[j] - base;
                        if (interval <= 0) continue;
                        const separation = j - i;
                        const weight = 1 / separation;
                        const tempo = (60 * sampleRate) / interval;
                        accumulateTempoEvidence(histogram, tempo, weight);
                    }
                }
                const results = Array.from(histogram.entries()).map(([tempo, count]) => ({ tempo, count }));
                results.sort((a, b) => b.count - a.count);
                return results;
            }

            function computeAutoCorrelation(signal, sampleRate) {
                const minLag = Math.max(1, Math.floor((sampleRate * 60) / MAX_BPM));
                const maxLag = Math.min(signal.length - 1, Math.floor((sampleRate * 60) / MIN_BPM));
                const correlations = new Float32Array(maxLag - minLag + 1);
                let energy = 0;
                for (let i = 0; i < signal.length; i++) {
                    energy += signal[i] * signal[i];
                }
                if (!energy) {
                    return [];
                }
                const histogram = new Map();
                for (let lag = minLag; lag <= maxLag; lag++) {
                    let sum = 0;
                    for (let i = 0; i < signal.length - lag; i++) {
                        sum += signal[i] * signal[i + lag];
                    }
                    correlations[lag - minLag] = sum / (signal.length - lag);
                }

                for (let i = 1; i < correlations.length - 1; i++) {
                    const current = correlations[i];
                    if (current <= 0) continue;
                    if (current > correlations[i - 1] && current >= correlations[i + 1]) {
                        const lag = i + minLag;
                        const tempo = (60 * sampleRate) / lag;
                        accumulateTempoEvidence(histogram, tempo, current);
                    }
                }
                const candidates = Array.from(histogram.entries()).map(([tempo, count]) => ({ tempo, count }));
                candidates.sort((a, b) => b.count - a.count);
                return candidates;
            }

            function tempoAlignmentScore(peaks, tempo, sampleRate) {
                if (peaks.length < 4) return 0;
                const limited = peaks.slice(0, Math.min(peaks.length, MAX_ALIGNMENT_PEAKS));
                if (limited.length < 4) return 0;
                const period = (60 / tempo) * sampleRate;
                if (!isFinite(period) || period <= 0) {
                    return 0;
                }
                const harmonics = [
                    { multiple: 1, weight: 1 },
                    { multiple: 2, weight: 0.7 },
                    { multiple: 3, weight: 0.5 }
                ];
                const twoPi = Math.PI * 2;
                let best = 0;
                for (let h = 0; h < harmonics.length; h++) {
                    const { multiple, weight } = harmonics[h];
                    if (!multiple) continue;
                    const effectivePeriod = period / multiple;
                    if (!isFinite(effectivePeriod) || effectivePeriod <= 2) continue;
                    let real = 0;
                    let imag = 0;
                    for (let i = 0; i < limited.length; i++) {
                        const cycles = limited[i] / effectivePeriod;
                        const fractional = cycles - Math.floor(cycles);
                        const angle = fractional * twoPi;
                        real += Math.cos(angle);
                        imag += Math.sin(angle);
                    }
                    const magnitude = Math.sqrt(real * real + imag * imag) / limited.length;
                    const score = magnitude * weight;
                    if (score > best) {
                        best = score;
                    }
                }
                return best;
            }

            function combineCandidates(visualCandidates, audialCandidates, envelopePeaks) {
                const combined = new Map();

                const accumulate = (source, weight) => {
                    source.forEach((candidate, index) => {
                        const tempoKey = Math.round(candidate.tempo * 4) / 4;
                        const existing = combined.get(tempoKey) || { tempo: tempoKey, count: 0 };
                        const baseScore = candidate.count || (source.length - index);
                        existing.count += baseScore * weight;
                        combined.set(tempoKey, existing);
                    });
                };

                accumulate(visualCandidates, VISUAL_WEIGHT);
                accumulate(audialCandidates, AUDIAL_WEIGHT);

                const results = Array.from(combined.values());
                const maxCount = Math.max(...results.map(r => r.count));

                if (maxCount > 0) {
                     results.forEach(candidate => {
                        const alignment = tempoAlignmentScore(envelopePeaks, candidate.tempo, TARGET_SAMPLE_RATE);
                        const normalizedCount = candidate.count / maxCount;
                        
                        let finalScore = Math.pow(normalizedCount, 0.3) * Math.pow(alignment, 2.0);
                        
                        if (candidate.tempo >= 95 && candidate.tempo <= 180) {
                            finalScore *= 1.5;
                        }

                        candidate.count = isNaN(finalScore) ? 0 : finalScore;
                        candidate.alignment = alignment;
                    });
                } else {
                     results.forEach(candidate => {
                        candidate.alignment = tempoAlignmentScore(envelopePeaks, candidate.tempo, TARGET_SAMPLE_RATE);
                        let finalScore = candidate.alignment;

                        if (candidate.tempo >= 95 && candidate.tempo <= 180) {
                            finalScore *= 1.5;
                        }
                        candidate.count = finalScore;
                     });
                }
               
                results.sort((a, b) => b.count - a.count);

                return results;
            }

            function performFullAnalysis(audioData, sampleRate) {
                const envelopeWindow = Math.max(1, Math.round(sampleRate * 0.02));
                const envelope = smoothAbsolute(audioData, envelopeWindow);
                const enhancedEnvelope = movingAverage(envelope, Math.round(envelopeWindow * 0.5));

                const minPeakSpacingSeconds = 60 / MAX_BPM;
                const envelopePeaks = detectPeaks(
                    enhancedEnvelope,
                    sampleRate,
                    PEAK_THRESHOLD_MULTIPLIER,
                    minPeakSpacingSeconds
                );

                const trimmedPeaks = envelopePeaks.slice(0, MAX_VISUAL_PEAKS);
                const peakTimes = trimmedPeaks.map(index => index / sampleRate);

                const visualCandidates = visualTempoEstimation(trimmedPeaks, sampleRate);

                const onsetSignal = new Float32Array(enhancedEnvelope.length);
                onsetSignal[0] = 0;
                for (let i = 1; i < enhancedEnvelope.length; i++) {
                    const diff = enhancedEnvelope[i] - enhancedEnvelope[i - 1];
                    onsetSignal[i] = diff > 0 ? diff : 0;
                }
                const onsetSmoothingWindow = Math.max(1, Math.round(sampleRate * ONSET_SMOOTHING_WINDOW_SECONDS));
                const onsetSmoothed = movingAverage(onsetSignal, onsetSmoothingWindow);
                const audialCandidates = computeAutoCorrelation(onsetSmoothed, sampleRate);

                const alignmentPeaks = envelopePeaks.slice(0, MAX_ALIGNMENT_PEAKS);
                const combinedCandidates = combineCandidates(visualCandidates, audialCandidates, alignmentPeaks).slice(0, 24);

                return {
                    candidates: combinedCandidates,
                    peaks: peakTimes
                };
            }

            function analyse(buffer) {
                const monoData = mixDownToMono(buffer);
                const downsampled = downsampleBuffer(monoData, buffer.sampleRate, TARGET_SAMPLE_RATE);
                const normalized = normalize(downsampled);

                // --- Overall Analysis ---
                const overallResult = performFullAnalysis(normalized, TARGET_SAMPLE_RATE);

                // --- Key Analysis ---
                const keyResult = detectKey(normalized, TARGET_SAMPLE_RATE);

                // --- Segmented Analysis for Variability ---
                const CHUNK_SECONDS = 20;
                const CHUNK_OVERLAP_SECONDS = 10;
                const MIN_SONG_DURATION_FOR_CHUNKING = CHUNK_SECONDS + 5;
                
                let tempoVariability = null;
                const songDuration = normalized.length / TARGET_SAMPLE_RATE;

                if (songDuration > MIN_SONG_DURATION_FOR_CHUNKING) {
                    const chunkSamples = CHUNK_SECONDS * TARGET_SAMPLE_RATE;
                    const overlapSamples = CHUNK_OVERLAP_SECONDS * TARGET_SAMPLE_RATE;
                    const stepSamples = chunkSamples - overlapSamples;
                    
                    const chunkBpms = [];

                    for (let offset = 0; (offset + chunkSamples) <= normalized.length; offset += stepSamples) {
                        const chunkData = normalized.slice(offset, offset + chunkSamples);
                        const chunkResult = performFullAnalysis(chunkData, TARGET_SAMPLE_RATE);
                        if (chunkResult.candidates && chunkResult.candidates.length > 0) {
                            chunkBpms.push(chunkResult.candidates[0].tempo);
                        }
                    }
                    
                    if (chunkBpms.length > 2) {
                        const primaryBpm = overallResult.candidates[0].tempo;
                        const tolerance = 0.05; // 5% tolerance for harmonic checks

                        const normalizedChunkBpms = chunkBpms.map(bpm => {
                            if (Math.abs(bpm - primaryBpm / 2) < (primaryBpm / 2) * tolerance) {
                                return bpm * 2;
                            }
                            if (Math.abs(bpm - primaryBpm * 2) < (primaryBpm * 2) * tolerance) {
                                return bpm / 2;
                            }
                            return bpm;
                        });

                        let min = Infinity, max = -Infinity, sum = 0, sumSq = 0;
                        for (const bpm of normalizedChunkBpms) {
                            if (bpm < min) min = bpm;
                            if (bpm > max) max = bpm;
                            sum += bpm;
                            sumSq += bpm * bpm;
                        }
                        const mean = sum / normalizedChunkBpms.length;
                        const variance = sumSq / normalizedChunkBpms.length - mean * mean;
                        const stdDev = Math.sqrt(Math.max(0, variance));
                        
                        tempoVariability = { min, max, stdDev };
                    }
                }
                
                return {
                    candidates: overallResult.candidates,
                    peaks: overallResult.peaks.map(p => p + (buffer.length / buffer.sampleRate - songDuration)), // Adjust peak times for full buffer
                    tempoVariability: tempoVariability,
                    key: keyResult.key,
                    keyConfidence: keyResult.confidence,
                    keySource: 'analysis',
                };
            }

            self.onmessage = (event) => {
                const { bufferData, sampleRate, numberOfChannels, length } = event.data;
                const buffer = {
                    length,
                    sampleRate,
                    numberOfChannels,
                    getChannelData: (i) => bufferData[i],
                };
                try {
                    const result = analyse(buffer);
                    self.postMessage(result);
                } catch (e) {
                    self.postMessage({ error: e.message });
                }
            };
        `;

        try {
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob));

            global.BpmAnalyser = {
                analyse: (buffer) => {
                    return new Promise((resolve, reject) => {
                        const channels = [];
                        for (let i = 0; i < buffer.numberOfChannels; i++) {
                            // slice() creates a copy that can be transferred.
                            channels.push(buffer.getChannelData(i).slice());
                        }

                        const messageHandler = (event) => {
                            worker.removeEventListener('message', messageHandler);
                            worker.removeEventListener('error', errorHandler);
                            if (event.data.error) {
                                reject(new Error(event.data.error));
                            } else {
                                resolve(event.data);
                            }
                        };
                        
                        const errorHandler = (event) => {
                            worker.removeEventListener('message', messageHandler);
                            worker.removeEventListener('error', errorHandler);
                            reject(new Error(event.message || "An error occurred in the BPM analysis worker."));
                            event.preventDefault();
                        };
                        
                        worker.addEventListener('message', messageHandler);
                        worker.addEventListener('error', errorHandler);

                        const transferable = channels.map(c => c.buffer);

                        worker.postMessage({
                            bufferData: channels,
                            sampleRate: buffer.sampleRate,
                            numberOfChannels: buffer.numberOfChannels,
                            length: buffer.length
                        }, transferable);
                    });
                }
            };
        } catch(e) {
            console.error("Failed to create BPM analysis worker. Analysis will not be available.", e);
            global.BpmAnalyser = {
                analyse: () => Promise.reject(new Error("BPM analysis worker could not be initialized."))
            };
        }
    })(window);
    </script>
    <script type="module" src="/index.tsx"></script>
</body>
</html>